# Firebase summary

* Cloud DDBB, onboarding&Authentication, messaging/notifications,
  analytics, Crash Reporting, Invites, Remote config... to
  speed-up mobile up development in Android/iOS/Web.
* It's not a replacement for existing APIs for building Android, iOS,
  or Web apps.

* Pricing: https://firebase.google.com/pricing/.
* Free tier includes:
  * Realtime Database: Up to  store 1Gb of Data and 100 simultaneous
    connections.
  * Cloud Functions: Up to 125,000 invocations per month.

* google-services.json: autogenerated in Firebase (web) Console.
  for Android projects.
  * It  defines a number of parameters that Firebase and the underlying
    Google Services need to operate on Android.
    More info at:
    https://developers.google.com/android/guides/google-services-plugin.

## Low code read/write how-to:
  final FirebaseDatabase database = FirebaseDatabase.getInstance();
  final DatabaseReference myRef = database.getReference("message");
  // Write to cloud DDBB how-to
  myRef.setValue("Hello, World!");
  // Read from DDBB as stream of events how-to
  myRef.addValueEventListener(new ValueEventListener() {
    @Override public void onDataChange(DataSnapshot dataSnapshot) {
      Log ( dataSnapshot.getValue(String.class);
    }
    @Override public void onCancelled(DatabaseError error) {
      Log( error.toString());
    }
  });

##  Firebase Onboarding and Authentication:
* easy API allowing to sign-in from federated providers and/or simple
  email/password scheme.
* Allows to integrate existing backend-apps.

* FirebaseUI:
  open source library that allows you to quickly do common Firebase
scenarios using best practices. One of these is Authentication, and
I'd recommend using this if you've never done auth before. There are
very many complex user flows when handling sign-up and sign-in, and
these are handled for you in FirebaseUI.
  Android version: https://github.com/firebase/FirebaseUI-Android

## Email/Password Onboarding and Sign-In how-to

1. Connect mobile/backend app to Firebase
2. Firebase console -> Authentication -> Sign-in method
   -> Enable Email/Password sign-in

### Android code:

* Simple app that just onboard and sign-in through e-mail flow:

   ```
   | {
   |   private static final int RC_SIGN_IN = 100; // unique ID for activity
   |   if(auth.getCurrentUser() != null /*  check if user is already signed in*/){
   |     startActivity(SignedInActivity.createIntent(this, null));
   |     finish();
   |   }
   |   ...
   |   @Override
   |   public void onClick(View v) {
   |     startActivityForResult(
   |       AuthUI.getInstance().
   |         createSignInIntentBuilder().build(), RC_SIGN_IN);
   |     }

   |   @Override
   |   protected void onActivityResult(
   |       int requestCode, int resultCode, Intent data){
   |      super.onActivityResult(requestCode, resultCode, data);
   |      if(requestCode == RC_SIGN_IN){
   |          handleSignInResponse(resultCode, data);
   |          return;
   |      }
   |   }
   | }
   ```
   If sign-in was successful, call the 'Signed In' activity or fail.

   ```
   @MainThread
   private void handleSignInResponse(int resultCode, Intent data) {
      IdpResponse response = IdpResponse.fromResultIntent(data);
      if (resultCode == ResultCodes.OK /* // Successfully signed in */) {
          startActivity(SignedInActivity.createIntent(this, response));
          finish();
          return;
      } else /* Sign in failed */ {
          ...
      }
      ...
   }
   ```
* After successful onboarding take a look at
  `Firebase Console -> Authentication -> Users tab`
* KEY-POINT: e-mail will be listed with a User UID jj3HDDMa9310…

  ```
  | public void signOut(){
  |   AuthUI.getInstance().signOut(this)
  |     .addOnCompleteListener(
  |       new OnCompleteListener<Void>() {
  |       @Override
  |       public void onComplete(@NonNull Task<Void> task) {
  |         if(!task.isSuccessful()){ ...}
  |         startActivity(MainActivity.createIntent(SignedInActivity.this));
  |         finish();
  |       }
  |     });
  | }
  ```

## Firebase Cloud Messaging (FCM)

* Over 98% of connected devices receive these messages in less than 500ms.
* massively scalable ( over a trillion messages each week).

* fine-grained target control:
  - driven by analytics to pick audiences
  - using topics
  - To unique device.
  - To all users of an app
  - To a single user
  - To message groups defined through FCM API.

* priorities and/or expiration dates can also be defined.
* You can also track how they are received.

* Two main ways that you can send messages:
  1. manually through the Firebase console.
  2. through backend server using the FCM API to dispatch messages.
     Example: https://github.com/lmoroney/fcm-app-server

### FCM Topics
* support unlimited topics and subscriptions per app.
* Message payload is is limited to 2 Kb, smaller than the typical 4Kb.
* """In order for your App server to know the details about each device, 
    so they can address them in messages, the FCM API gives you a 
    registration token that is unique to each device. Once you have this 
    token, you (the user app) pass the details to your server. It will 
    need them when it calls the FCM API.""""

1. Step 1. Create DDBB in server:
   ```
   | CREATE TABLE IF NOT EXISTS `fcm_users` (
   | `id` int(11) NOT NULL,
   | `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
   | `fcm_regID` text NOT NULL
   | )
   ```
   ```
   | <?php
   | $json = array();
   |     $fcm_regid = $_POST["regid"]; // GCM Registration ID, // Store user details in db
   |     …
   |     $res = $db->storeUser($fcm_regid);
   |     echo "Done!";
   | ?>
   ```

   ```
   | <?php
   | $message = "Test Message";
   | $data = array("m" => $message);
   | $regid = "testid";
   | $url = 'https://fcm.googleapis.com/fcm/send';
   | $headers = array(
   |    'Authorization: key=<Your Auth Key>', // To get Auth_key from FCM: “project settings” -> 'Cloud Messaging' tab -> Server Key
   |    'Content-Type: application/json');    // (autopopulated when creating the project).
   | $ch = curl_init();
   | curl_setopt($ch, CURLOPT_URL, $url);
   | curl_setopt($ch, CURLOPT_POST, true);
   | curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);
   | curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
   | curl_setopt ($ch, CURLOPT_SSL_VERIFYHOST, 0);
   | curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
   | 
   | $POST_BODY = array( /* JSON with id_list to send to+ msg to send */
   |    'registration_ids' => $regdata,
   |    'data' => $data  );
   | curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($POST_BODY));
   | $result = curl_exec($ch);
   | if ($result === FALSE) {
   |     die('Curl failed: ' . curl_error($ch));
   | }
   | curl_close($ch);
   | echo($result);
   | ?>
   ```
1. next step) update the app so it registers itself with this app 
  server, and then we can send messages to it from the home page.  <br/>
  Updating the App: when the user presses the button, the registration 
  id should be attained from Firebase, and passed to the server.

   ```
   | public class CallFCM 
   |   extends AsyncTask<HashMap<String, String>, String, String> {
   | 
   |   private String parasmToURLQuery(…) { ..}
   | 
   |   @Override
   |   protected String doInBackground(HashMap<String, String>... params) {
   |     // Replace this URL with your register script.
   |     URL url = new URL(http://laurencemoroney.com/fcm/register.php);
   | 
   |     HttpURLConnection conn = (HttpURLConnection) url.openConnection();
   |     conn.setReadTimeout(10000);
   |     conn.setConnectTimeout(15000);
   |     conn.setRequestMethod("GET");
   |     conn.setDoInput(true);
   |     conn.setDoOutput(true);
   |     OutputStream os = conn.getOutputStream();
   |     BufferedWriter writer = new BufferedWriter(
   |             new OutputStreamWriter(os, "UTF-8"));
   |     writer.write(paramsToURLQuery (params));
   |     writer.flush();
   |     writer.close();
   |     os.close();
   |     conn.connect();
   |     int responseCode=conn.getResponseCode(); // ··· Register to AppServer.
   | 
   |     if (responseCode != HttpsURLConnection.HTTP_OK)  throw …
   |     String line;
   |     Final BufferedReader br=new BufferedReader(new InputStreamReader
   |     (conn.getInputStream()));
   |     while ((line=br.readLine()) != null) {
   |        response+=line;
   |     }
   |     return response;
   |   }
   | }
   ```

   ```
   | (UIClass)
   |  ...
   |  public void onClick(View v) {
   |      HashMap<String, String> params = new HashMap();
   |      params.put("regid", FirebaseInstanceId.getInstance().getToken());
   |      new CallFCM().execute(params);
   |  }
   ```



# Cloud Messaging Server Realtime Database
* <https://firebase.google.com/docs/cloud-messaging/server> [[{PM.TODO}]]

# Cloud Storage
* cloud-hosted NoSQL-based database.
* Use case example: syncing across connected devices.
* Works also offline through local cache.
* event-driven database (it works very differently from traditional SQL databases).
  * There's no server-side code and database access tiers; 
  * all coding is done in the client.
  * Whenever data changes in the database, events are fired in the client code,
    and you can then handle and update the state of your user interface in response.

# Firebase Test Lab

* Firebase Test Lab allows to take advantage of devices that are hosted by Google
  in a Test Center for you!

# Crash Reporting

* Crash Reporting helps provides a Stack Trace of all crashes in the Firebase Console

# Cloud Functions

* Cloud Functions facilitate writing code that responds to events on Firebase elements.
  (changes in the Realtime Database, Authentication, ...)

# Remote Config

* is a cloud service that provides server-side variables that can be
  driven by analytics, allowing you to change the behavior and/or
  appearance of your app without requiring an app update.   [[{PM.low_code}]]

* Example: you are building an e-commerce app, and you want to periodically
  provide discounts to your users. A remote config variable contains the 
  value of the discount:<br/>

# App Indexing:
* Logically, if users are searching for content that's already in your app,
  and they previously made the decision to install that app, then the app should
  be surfaced, and the content should be opened in that app directly from search.
* App Indexing allows users to search on local app when doing “Google” searchs
  you to, you'll see how to link your site and app so that Google Search knows
  to make the connection!

# App Invites

* App Invites help friends discover great apps.

# AdMob

* AdMob allows to add banner ads, interstitial ads, video, or native ads
  within your app.

# Google Analytics

* Google Analytics helps you understand your audience well, as well 
  as driving technologies such as Firebase Remote Config, and Cloud 
  Messaging!
